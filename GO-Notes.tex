    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    %%                                                                 %%    
    %%                 Eine Kurze Zusammenfassung von                  %%    
    %%                 Graphentheorie und Optimierung                  %%    
    %%                                                                 %%    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%  Markup    : LaTex
%  Maintainer: jan.winkelmann@tuhh.de
%  URL       : http://github.com/reforged/GO-Zusammenfassug
%  Date      : 2010/8/26
%  TODO      : Der gesamte Optimierungsteil

%Schriftgröße, Layout, Papierformat, Art des Dokumentes
\documentclass[10pt,oneside,a4paper]{scrreprt}

%Einstellungen der Seitenränder
\usepackage[left=1cm,right=1cm,top=2cm,bottom=2cm]{geometry}
\usepackage{listings}
\usepackage{color}


\parindent 0em
\parskip 0.3em

\usepackage{verbatim} 
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\newcommand\boxit[1]{%
  \hspace*{7mm}\frame{\parbox{500pt}{ \vspace*{3mm}\hspace*{2mm} \parbox{480pt}{#1}\vspace*{3mm}}}
}

\newcommand\boxtwo[1]{%
  \hspace*{7mm}\frame{\parbox{238pt}{ \vspace*{3mm}\hspace*{2mm} \parbox{230pt}{#1}\vspace*{3mm}}}
}


\begin{document}
    % \section*{Relationen}
    % \subsubsection*{Funktionen}
    % \boxit{
    % injektiv: \hfill $ \forall x,y \in Y : f(x) = f(y) \Rightarrow x = y$ \\
    % Linkseindeutig: Jedes Element der Zielmenge ist h\"ochstens einmal Funktionswert
    % }
    
    \section*{Graphentheorie}

    Graph: $G = (V,E)$\\
    Baum: $|E| = |V| - 1$\\
    Spannbaum von G: Teilgraph von G und Baum der alle Knoten von G ent\"allt, not unique. \\
    Bipartit: $G = (V_1 \cup V_2, E)$,
    G ist bipartit $\Leftrightarrow$ G enth\"allt keinen Kreis gerader l\"ange\\
    Paarung $P$ von $G$: $P$ hat keine gemeinsamen Endpunkte. --- $P \subset E$ es gibt nur Paare\\
    Knoten\"uberdeckung $U$ von $G$: $\forall$ Kanten $uv$ gilt $u \in U$ OR $v \in U$. --- $U \subset V$ s.d. jede Kante hat ein Ende in $U$\\
    K\"onig-Egervary: $G$ bipartit $\Rightarrow$ $|$maximale Paarung$| == |$minimale Knotenueberdeckung$|$ \\

    Flussnetze:\\
    $N=(D,\kappa,s,q)$ , D Digraph, $\kappa: E \rightarrow \mathbb{R}_0^{+}$ Kostenfunktion\\

    Schnitt eines Flussnetzes:\\
    Teilmenge S, die die Quelle aber nicht die Senke ent\"allt.\\
    Kapazit\"at eines Schnittes: $\kappa(S)$ = Kapazit\"at der Endknoten des Schnittes.
    Minimaler Schnitt S = $\forall S'$ $\kappa(S) \leq \kappa(S')$\\
    maximaler Fluss == min Schnitt

    \subsection*{Planarit\"at}
    f\"ur ebene Darstellungen gelten: $n-m+f=2$ ,n=Knoten, m=Kanten, f=Fl\"achen\\
    if $n \geq 3$ $3n-6$ Kanten h\"ochsten\\
    if $n \geq 3$ hat h\"ochstens $g \geq 3$, g = Umfang des Graphen???? $max\{g(n-2)/(g-2)m n-1\} Kanten$ \\
    ein Graph ist planar $\Leftrightarrow$ kein subgraph von G ist hom\"oomorph zu $k_5$, $k_{3,3}$

    \subsection*{Datenstrukturen}
    Adjazenzmatrix\\
    \boxit{ $n \cdot n$, immer symetrisch\\
    $a_{ij} = 1$ falls $v_iv_j \in E$, $0$ sonst
    }

    Inzidenzmatrix\\
    \boxit{ $n\cdot m$, $e_{ij} = 1 $ wenn $v_i$ mit $e_j$ inzidiert, $0$ sonst\\
    Spaltensume immer $2$, Reihensumme = Grad des Knoten
    }
    
    Inzidenzliste\\
    \boxit{ Eine Liste pro Knoten, die alle Nachbarknoten enth\"allt.\\
    $L_{v_n} = \{x | \exists_{e \in E}: e = (v_n,x) \}$
    
    }

    \subsection*{Netzwerke}
    Floyd-Warshal (S.288)\\
    \boxit{
    K\"urzeste Abst\"ande f\"ur alle Knoten $O(|V|^3)$ \\

    for k=1 to n do: $ d(u,w) = min(d^{k-1}(u,w), d^{k-1}(u,v_k) + d^{k-1}(v_k,w))$\\
    Mit jeder Iteration gucken ob es einen k\"urzeren Weg \"uber den Knoten $v_k$ gibt
    }
    
    Dijkstra (S.289)\\
    \boxit{
    K\"urzeste Wege f\"ur einzelnen Knoten $O(|V|^2) oder O(|E| + |V| log |V|)$ \\
    Nachbarkanten untersuchen nach k\"urzeren Wegen
    }

    Kurskal (S.291)\\
    \boxit{
    min. Spannb\"aume \\
    Durchlaufe Kanten nach wachsendem Gewicht, f\"uge hinzu, wenn Komponente noch nicht im Spannbaum
    }

    Ford-Fulkerson (S.293)\\
    \boxit{
      bestimmet maximalen Fluss in N\\
      erst alle Knoten markieren, dann Fluss vergr\"ossern und erneut markieren.
      %TODO: negative kanten...
    }
  \section*{Optimierung}
  % TODO: rezepte, boilerplate
  %       N(x), C()?
  Entscheidungsprobleme: NP--Vollst\"andig\\
  Opimierungsprobleme: NP--Hart\\
  Eine Maximierung von $f$ entspricht einer Minimierung von $-f$ [$max\{ f(x) | x \in X \} == -min\{ -f(x) | x \in X\}$]\\
  \subsection*{Backtracking -- Kombinatorische Optimierung (S. 307)}
  Exhaustives durchsuchen des gesamten Suchraumes.\\
  NUR INTERFACES SPEZIFIZIEREN??  \\
  Abschneiden von Teilb\"aumen durch Bonding--Funktionen: (S. 310)\\
  $x = (x_1, ..., x_k)$ Teill\"osung und $P(x)$ der zugeh\"orige Maximalwert aller L\"osungen von $x$ \\
  Bonding Funktion $B(x)$ s.d. $\forall x B(x) \ge P(x)$. So kann abgeschnitten werden wenn $B(x) \le$ dem aktuellen H\"ochstwert
  
  \subsection*{Heuristiken (S. 313)}
  Ordnet jeder L\"osung eine Nachbarschaft von anderen L\"osungen zu.\\
  Nachbarschaftsfunktion $N(x)$
  
  \subsubsection*{Bergauf--Methode}
  Als Nachbarschaft von $x$ wird ein Wert $y$ mit $f(y) > f(x)$ gesucht.\\
  Sobald $f(y)$ nicht mehr gr\"osser wird aufgeh\"ort zu suchen.
  
  \subsubsection*{Simulated Annealing (S. 316)}
  Falls $f(y) < f(x)$ benutzt $random \in [0,1] < e^{\frac{f(y)-f(x)}{T}}$ um zu entscheiden ob $x$ (doch) durch $y$ ersetzt wird.\\
  Abk\"uhlungsplan $T$. $T_0$ wird hoch gehw\"ahlt und nach jeder Iteration um einen Prozensatz gesenkt bis Endtemperatur $T_f$ erreicht ist\\
  Dies soll das verlassen von lokalen Optima am Anfang des Prozesses erm\"oglichen.
  
  \subsubsection*{Genetische Algorithmen}
  Initialisiert Population P mit N Individuen\\
  Iteriere: Selektion, Mutation, Kreuzung\\
  
  Selektion: W\"ahle die besten N Individuen aus P\\
  Mutation: Ersezte Individuen durch Benachbarte\\
  Kreuzung: Kreuze Paare aus der Population\\
  \subsection*{Lineare Programmierung}
  
  \section*{Boilerplate}

  \boxtwo{
  \hspace*{\fill} \textbf{Bergauf}\hspace*{\fill} \\
  
  \textbf{w\"ahle} zul\"assige L\"osung $x \in X$ //Startpunkt\\
  $x^* \gets x$ //beste L\"osung\\
  $searching \gets$ \textbf{true}\\
  \textbf{while} ($searching$) \{\\
  \hspace*{5mm} $y \gets H(x)$\\
  \hspace*{5mm} \textbf{if} ($y == fail$)\\
  \hspace*{10mm}  $searching \gets$ \textbf{false}\\
  \hspace*{5mm} \textbf{else} \{ \\
  \hspace*{10mm} $x \gets y$\\
  \hspace*{10mm} \textbf{if} ($f(x) > f(x^*)$)\\
  \hspace*{15mm} $x^* \gets x$\\
  \hspace*{5mm} \}\\
  \}\\
  }
  \boxtwo{
  \hspace*{\fill} \textbf{Simulated Annealing}\hspace*{\fill} \\

  T $\gets$ T$_0$\\
  \textbf{w\"ahle} zul\"assige L\"osung $x \in X$ //Startpunkt\\
  $x^* \gets x$ //beste L\"osung\\
  \textbf{while} (T $\ge$ T$_f$)\{\\
  \hspace*{5mm} $y \gets H(x)$\\
  \hspace*{5mm} \textbf{if} ($y == fail$)\\
  \hspace*{10mm}  return $x^*$\\
  \hspace*{5mm} \textbf{if} ($f(y) > f(x)$) \{\\
  \hspace*{10mm} $x \gets y$ //Aufw\"artsbewegung\\
  \hspace*{10mm} \textbf{if} ($f(x) > f(x^*)$)\\
  \hspace*{15mm} $x^* \gets x$\\
  \hspace*{5mm} \}\\
  \hspace*{5mm} \textbf{else} \{\\
  \hspace*{10mm} $r \gets random(0,1)$ //Abw\"artsbewegung\\
  \hspace*{10mm} \textbf{if} ($r < e^{\frac{f(y)-f(x)}{T}} $)\\
  \hspace*{15mm} $x \gets y$\\
  \hspace*{10mm} T $\gets \alpha \cdot T$ // $\alpha = .99$\\
  \hspace*{5mm}\}\\
  \}\\
  }\\
  
  \boxtwo{
  \hspace*{\fill} \textbf{Genetische Algorithmen}\hspace*{\fill} \\

  }
\end{document}